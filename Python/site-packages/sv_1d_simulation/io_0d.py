# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
todo: use the example codes of

        /home/jonathanpham/Documents/Marsden_Lab/oneD_to_threeD_mapping/suhaas_martin/test/aortofem/generate_centerline_in_2_steps/generate_centerline.py

        /home/jonathanpham/Documents/Marsden_Lab/oneD_to_threeD_mapping/suhaas_martin/test/bifurcation/coarse/generate_centerline/bifurcation.py

        /home/jonathanpham/Documents/Marsden_Lab/oneD_to_threeD_mapping/suhaas_martin/test/tube/centerline_generation/generate_centerlines.py

to test this code and create a sample centerline and 0d input file, when I am done writing this code.
    Use the /home/jonathanpham/Documents/Marsden_Lab/misc/test_sv_0d/generate_centerline.py code
"""

# last here - test this code using the code in /home/jonathanpham/Documents/Marsden_Lab/misc/test_sv_0d/generate_centerline.py

# todo: delete any unneeded or unused functions in this code

"""
This module handles file i/o for the SimVascular 0D solver (https://github.com/StanfordCBCL/0D_LPN_Python_Solver ; https://github.com/StanfordCBCL/CVLPNSolver).
"""
from os import path
import logging
import re
from .manage import get_logger_name
from .parameters import OutflowBoundaryConditionType, MaterialModel

import numpy as np
from collections import OrderedDict

import vtk.util.numpy_support as nps
from vtk import vtkIdList
from vtk import vtkPoints, vtkLine, vtkCellArray, vtkPolyData, vtkXMLPolyDataWriter
from .utils import SurfaceFileFormats, read_polydata, write_polydata
from .io_1d import write_solver_section_header
from .io_headers_0d import Headers
from collections import namedtuple
import pdb

# Define flow data tuple.
FlowData = namedtuple('FlowData', 'time flow')


def write_0d_solver_file(mesh, params):
    """ Write a 0d solver input file.
    """
    # print("Write solver file.")
    mesh.logger.info("Write 0d solver file.")
    output_dir = params.output_directory
    file_name = path.join(output_dir, params.solver_output_file)
    model_name = params.model_name
    sp = mesh.space
    # print("Solver file %s" % file_name)

    # Open file
    ofile = mesh.Open(file_name, "w")

    # write header
    header = Headers().model(model_name)
    write_solver_section_header(mesh, ofile, header)

    # Write node section.
    write_solver_nodes(mesh, ofile, params)

    # Write joint section.
    write_solver_joints(mesh, ofile, params)

    # Write junctions section.
    write_solver_junctions(mesh, ofile, params)

    # Write element section.
    write_solver_elements(mesh, ofile, params)

    # Write inlet boundary condition section.
    write_inlet_bc(mesh, ofile, params)

    ofile.close()


def write_solver_nodes(mesh, ofile, params):
    """ Write a solver input file nodes section.
    """
    header = Headers().node

    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header)

    lcoef = params.lcoef
    sp = mesh.space

    # loop branches
    for ids, nodes in zip(mesh.point_data['id'].values(), mesh.point_data['coord'].values()):
        # loop nodes
        for i, node in zip(ids, nodes):
            ofile.writeln("NODE " + str(i) + sp + sp.join(str(lcoef * node[j]) for j in range(3)))


def write_solver_joints(mesh, ofile, params):
    """ Write a solver input file joints section.
    """
    header1 = Headers().joint1
    header2 = Headers().joint2

    # Joint header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header1)

    # JointInlet and JointOutlet header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header2)

    sp = mesh.space
    seg_connectivity = mesh.seg_connectivity
    seg_rear = mesh.seg_rear

    for i in range(0, len(seg_connectivity)):
        joint = "JOINT J" + str(i) + sp + str(seg_rear[i])
        jin = "IN" + str(i)
        jout = "OUT" + str(i)
        ofile.writeln(joint + sp + jin + sp + jout)
        ofile.writeln("JOINTINLET IN" + str(i) + sp + "1 " + str(seg_connectivity[i][0]))
        ofile.write("JOINTOUTLET OUT" + str(i) + sp + str(len(seg_connectivity[i]) - 1))
        for j in range(1, len(seg_connectivity[i])):
            ofile.write(sp + str(seg_connectivity[i][j]))
        ofile.write("\n\n")


def write_solver_junctions(mesh, ofile, params):
    """ Write a solver input file junctions section.
    """
    # todo: update this function to work for any junction model, ie NORMAL_JUNCTION or LOSSY_JUNCTION
    header = Headers().junction

    # Junction header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space

    for i in range(0, len(mesh.seg_connectivity)):
        junction = "JUNCTION_MODEL J" + str(i) + sp + "NORMAL_JUNCTION"
        ofile.writeln(junction)
    ofile.write("\n")


def compute_average_segment_radius(segment_inlet_area, segment_outlet_area):
    """
    Purpose:
        Compute the average radius for a given vessel segment
    Inputs:
        float segment_inlet_area
            = cross-sectional area of a segment's inlet face
        float segment_outlet_area
            = cross-sectional area of a segment's outlet face
    Returns:
        float average_vessel_radius
            = (segment inlet radius + segment outlet radius)/2.0
    """
    return (np.sqrt(segment_inlet_area/np.pi) + np.sqrt(segment_outlet_area/np.pi))/2.0


def create_Ehor_lambda_function(k1, k2, k3, material_type):
    """
    Purpose:
        Create a lambda function to compute E*h/r as a function of r. This value is used to compute vessel capacitance.
        Sources:    Alison Marsden's CME 285 Spring 2019 Course Reader, pg 68
                        http://simvascular.github.io/docs1DSimulation.html#format_material
                    http://simvascular.github.io/docs1DSimulation.html
    Available material models:
        LINEAR:
            Eh/r = k1
        OLUFSEN:
            Eh/r = k1*exp(k2*r) + k3
    Inputs:
        float k1
        float k2
        float k3
        string material_type
            = "LINEAR" or "OLUFSEN"
    Returns:
        lambda function
    """
    if material_type == "OLUFSEN":
        return lambda r: k1*np.exp(k2*r) + k3
    elif material_type == "LINEAR":
        return lambda r: k1
    else:
        message = "Error. Material type, " + material_type + ", has not been implemented. Only implemented materials are OLUSEN and LINEAR."
        raise ValueError(message)


def calc_segment_tangent_vector(segment_inlet_node_coords, segment_outlet_node_coords):
    """
    Purpose:
        Compute the (un-normalized) tanget vector for the vessel segment, where the vector points from the inlet node (placed at the origin) to the outlet node
    Inputs:
        np.array segment_inlet_node_coords
            = np.array([x, y, z]) coordinates of a segment's inlet node
        np.array segment_outlet_node_coords
            = np.array([x, y, z]) coordinates of a segment's outlet node
    Returns:
        np.array([x, y, z]) vessel_vector
            = tangent vector, in the form of np.array([x, y, z]) vector components, for the vessel segment
    """
    vessel_vector = segment_outlet_node_coords - segment_inlet_node_coords
    return vessel_vector


def compute_resistance(viscosity, length, avg_radius):
    """
    Purpose:
        Compute resistance using Poiseuille flow
    Inputs:
        ...
    Returns:
        float R
            = resistance value = 8*viscosity*L/(pi*r^4)
    """
    return 8.0*viscosity*length/(np.pi*(avg_radius**4))


def compute_inductance(length, density, avg_radius):
    """
    Purpose:
        Compute inductance using Poiseuille flow
    Inputs:
        ...
    Returns:
        float L
            = inductance value = L*density/(pi*r^2)
    """
    return length*density/(np.pi*(avg_radius**2))


def compute_capacitance(length, avg_radius, Ehor_func):
    """
    Purpose:
        Compute capacitance using Poiseuille flow
    Inputs:
        ...
    Returns:
        float C
            = capacitance value = 3*L*pi*r^3/(2*E*h)
    """
    return 3.0*length*np.pi*(avg_radius**2)/(2*Ehor_func(avg_radius))


def write_solver_elements(mesh, ofile, params):
    """ Write a solver input file elements section.
    """
    # todo: clean up this functions; there are some leftover remnants from that 1d version of this function ( write_solver_segments() ) that I dont need for this 0d version
    header = Headers().element
    write_solver_section_header(mesh, ofile, header)
    mesh.logger.info("Write solver element section ...")

    sp = mesh.space

    uniform_bc = params.uniform_bc
    uniform_material = params.uniform_material
    dx = params.element_size
    min_num_elems = params.min_num_elems
    inflow_data = mesh.inflow_data

    mesh.logger.info("Uniform BC: %s" % uniform_bc)
    for t in set(mesh.bc_type.values()):
        mesh.logger.info("Outflow BC: %s" % t)
    mesh.num_elements = 0

    assert uniform_material, 'non-uniform material not implemented'

    # loop branches
    for (branch, ids), lengths in zip(mesh.cell_data['id'].items(), mesh.cell_data['length'].values()):
        # loop nodes
        for i, (j, length) in enumerate(zip(ids, lengths)):
            if uniform_material:
                matname = "MAT1"
            else:
                matname = "MAT_group" + str(j)

            numfe = int(round(length / dx))

            if numfe < min_num_elems:
                numfe = min_num_elems

            mesh.num_elements += numfe

            p0 = mesh.point_data['id'][branch][i]
            p1 = mesh.point_data['id'][branch][i + 1]
            a0 = mesh.point_data['area'][branch][i]
            a1 = mesh.point_data['area'][branch][i + 1]
            p0_coords = params.lcoef * mesh.point_data['coord'][branch][i]
            p1_coords = params.lcoef * mesh.point_data['coord'][branch][i + 1]

            avg_radius = compute_average_segment_radius(a0, a1)
            Ehor_func = create_Ehor_lambda_function(params.olufsen_material_k1, params.olufsen_material_k2, params.olufsen_material_k3, params.material_model)

            segment_inlet_node_coords = p0_coords
            segment_outlet_node_coords = p1_coords
            segment_tangent_vector = calc_segment_tangent_vector(segment_inlet_node_coords, segment_outlet_node_coords)

            # todo: update this function to work for an element with ANY properties (ie density, viscosity, Ehor, etc)
            ofile.write("ELEMENT" + sp + "branch" + str(branch) + "_seg" + str(i) + sp + str(j) + sp +
                        str(avg_radius) + sp +
                        str(length) + sp + str(params.density) + sp + str(params.viscosity) + sp + str(Ehor_func(avg_radius)) + sp + str(p0) + sp +
                        str(p1) + sp + str(segment_tangent_vector[0]) + sp + str(segment_tangent_vector[1]) + sp + str(segment_tangent_vector[2]))

            if j in mesh.terminal:
                if uniform_bc:
                    outflow_bc = OutflowBoundaryConditionType.RCR.upper()
                    ofile.write(" " + outflow_bc + " " + outflow_bc + "_1")
                    msg = "While writing solver elements encountered: group_terminal[seg_list[i]] == 1"
                    mesh.logger.error(msg)
                    raise RuntimeError(msg)
                else:
                    bc_id = mesh.terminal.index(j)
                    bc_name = list(mesh.outlet_face_names_index.keys())[bc_id]
                    bc_type = mesh.bc_type[bc_name].upper()
                    ofile.write(" " + bc_type + " " + bc_type + "_" + str(bc_id))
            else:
                ofile.write(" NOBOUND NONE")

            if params.uniform_0d_element_type:
                zerod_element_values = []
                if params.zerod_element_type == "R":
                    zerod_element_values.append(compute_resistance(params.viscosity, length, avg_radius))
                elif params.zerod_element_type == "RC":
                    zerod_element_values.append(compute_resistance(params.viscosity, length, avg_radius))
                    zerod_element_values.append(compute_capacitance(length, avg_radius, Ehor_func))
                elif params.zerod_element_type == "RL":
                    zerod_element_values.append(compute_resistance(params.viscosity, length, avg_radius))
                    zerod_element_values.append(compute_inductance(length, params.density, avg_radius))
                elif params.zerod_element_type == "RCL":
                    zerod_element_values.append(compute_resistance(params.viscosity, length, avg_radius))
                    zerod_element_values.append(compute_capacitance(length, avg_radius, Ehor_func))
                    zerod_element_values.append(compute_inductance(length, params.density, avg_radius))
                elif params.zerod_element_type == "L":
                    zerod_element_values.append(compute_inductance(length, params.density, avg_radius))
                elif params.zerod_element_type == "C":
                    zerod_element_values.append(compute_capacitance(length, avg_radius, Ehor_func))

                ofile.writeln(" " + params.zerod_element_type + ''.join(sp + str(val) for val in zerod_element_values))
            else: # todo: need to account for 0d models where the 0d elements / segments have different 0d element types (in other words, have multiple 0d element types in a single 0d model)
                msg = "Non-uniform 0d element types (meaning each 0d element in the 0d model does not have the same 0d element type) not implemented yet."
                mesh.logger.error(msg)
                raise RuntimeError(msg)

    ofile.writeln("")
    ofile.writeln("")
    ofile.writeln("DATATABLE INFLOW LIST")

    if not inflow_data:
        ofile.writeln("Copy and paste inflow data here.")
    else:
        for value in inflow_data:
            ofile.writeln(" %f %f" % (value.time, value.flow))

    ofile.writeln("ENDDATATABLE")
    ofile.writeln("")
    ofile.writeln("")

    if uniform_bc:
        ofile.writeln("DATATABLE " + outflow_bc_uc + "_1 LIST")
        ofile.writeln(sp)
        ofile.writeln("ENDDATATABLE")
        ofile.writeln("")
    else:
        for i, name in enumerate(mesh.outlet_face_names_index.keys()):
            bc_val = mesh.bc_map[name]
            bc_type = mesh.bc_type[name]
            ofile.writeln("DATATABLE " + bc_type.upper() + "_" + str(i) + " LIST")

            if bc_type == OutflowBoundaryConditionType.RCR or bc_type == OutflowBoundaryConditionType.RESISTANCE:
                for j in bc_val:
                    ofile.writeln("0.0 " + str(j))

            elif bc_type == OutflowBoundaryConditionType.CORONARY:
                # write parameters
                for v in ['Ra1', 'Ra2', 'Ca', 'Cc', 'Rv1', 'P_v']:
                    ofile.writeln("-1.0 " + str(bc_val['var'][v]))

                # write time / pressure pairs
                for t, p in zip(bc_val['time'], bc_val['pressure']):
                    ofile.writeln(str(t) + sp + str(p))

            ofile.writeln("ENDDATATABLE")
            ofile.writeln("")

    ofile.writeln("")
    ofile.writeln("")


def write_inlet_bc(mesh, ofile, params):
    """ Write a solver input file inlet boundary condition section.
    """
    # todo: update this function to work for any BC (flow, pressure, etc) for the inlet segment
    header = Headers().inlet_bc
    write_solver_section_header(mesh, ofile, header)

    inlet_face_seg_num = params.inlet_face_seg_num

    ofile.writeln("INLET_BOUNDARY_CONDITION " + str(inlet_face_seg_num) + " FLOW INFLOW")
    ofile.writeln("")
