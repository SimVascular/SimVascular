# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
This module handles file i/o for the SimVascular 0D solver
"""
from os import path
import logging
import re
from .manage import get_logger_name
from .parameters import OutflowBoundaryConditionType, MaterialModel

import numpy as np
from collections import OrderedDict

import vtk.util.numpy_support as nps
from vtk import vtkIdList
from vtk import vtkPoints, vtkLine, vtkCellArray, vtkPolyData, vtkXMLPolyDataWriter
from .utils import SurfaceFileFormats, read_polydata, write_polydata
from .io_1d import write_solver_section_header, write_solver_joints, write_solver_nodes
from .io_headers import Headers
from collections import namedtuple
import pdb

# Define flow data tuple.
FlowData = namedtuple('FlowData', 'time flow')


def write_0d_solver_file(mesh, params, model):
    """ Write a 0d solver input file.
    """
    # print("Write solver file.")
    mesh.logger.info("Write 0d solver file.")
    output_dir = params.output_directory
    file_name = path.join(output_dir, params.solver_output_file)
    model_name = params.model_name
    sp = mesh.space
    # print("Solver file %s" % file_name)

    # Open file
    ofile = mesh.Open(file_name, "w")

    # write header
    header = Headers().model(model_name)
    write_solver_section_header(mesh, ofile, header)

    # Write node section.
    write_solver_nodes(mesh, ofile, params)

    # Write joint section.
    write_solver_joints(mesh, ofile, params)

    # Write junctions section.
    write_solver_junctions(mesh, ofile)

    # Write element section.
    write_solver_elements(mesh, model, ofile, params)

    # Write inlet boundary condition section.
    write_inlet_bc(mesh, ofile, params)

    # Write solver options section.
    write_solver_options(mesh, ofile, params)

    ofile.close()


def write_solver_junctions(mesh, ofile):
    """ Write a solver input file junctions section.
    """
    # todo: update this function to work for any junction model, ie NORMAL_JUNCTION or LOSSY_JUNCTION
    header = Headers().junction

    # Junction header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space

    for i in range(0, len(mesh.seg_connectivity)):
        junction = "JUNCTION_MODEL J" + str(i) + sp + "NORMAL_JUNCTION"
        ofile.writeln(junction)
    ofile.write("\n")


def write_solver_elements(mesh, model, ofile, params):
    """ Write a solver input file elements section.
    """
    # todo: clean up this functions; there are some leftover remnants from that 1d version of this function ( write_solver_segments() ) that I dont need for this 0d version
    header = Headers().element
    write_solver_section_header(mesh, ofile, header)
    mesh.logger.info("Write solver element section ...")

    sp = mesh.space

    uniform_bc = params.uniform_bc
    uniform_material = params.uniform_material
    dx = params.element_size
    min_num_elems = params.min_num_elems
    inflow_data = mesh.inflow_data

    mesh.logger.info("Uniform BC: %s" % uniform_bc)
    for t in set(mesh.bc_type.values()):
        mesh.logger.info("Outflow BC: %s" % t)
    mesh.num_elements = 0

    assert uniform_material, 'non-uniform material not implemented'

    # loop branches
    for (branch, ids), lengths in zip(mesh.cell_data['id'].items(), mesh.cell_data['length'].values()):
        # loop nodes
        for i, (j, length) in enumerate(zip(ids, lengths)):
            numfe = int(round(length / dx))

            if numfe < min_num_elems:
                numfe = min_num_elems

            mesh.num_elements += numfe

            p0 = mesh.point_data['id'][branch][i]
            p1 = mesh.point_data['id'][branch][i + 1]

            # todo: update this function to work for an element with ANY properties (ie density, viscosity, Ehor, etc)
            ofile.write("ELEMENT" + sp + "branch" + str(branch) + "_seg" + str(i) + sp + str(j) + sp +
                        str(-1) + sp +
                        str(length) + sp + str(params.density) + sp + str(params.viscosity) + sp + str(-1) + sp + str(p0) + sp +
                        str(p1) + sp + str(-1) + sp + str(-1) + sp + str(-1))

            if j in mesh.terminal:
                if uniform_bc:
                    outflow_bc = OutflowBoundaryConditionType.RCR.upper()
                    ofile.write(" " + outflow_bc + " " + outflow_bc + "_1")
                    msg = "While writing solver elements encountered: group_terminal[seg_list[i]] == 1"
                    mesh.logger.error(msg)
                    raise RuntimeError(msg)
                else:
                    bc_id = mesh.terminal.index(j)
                    bc_name = list(mesh.outlet_face_names_index.keys())[bc_id]
                    bc_type = mesh.bc_type[bc_name].upper()
                    ofile.write(" " + bc_type + " " + bc_type + "_" + str(bc_id))
            else:
                ofile.write(" NOBOUND NONE")

            out = ''
            if params.uniform_0d_element_type:
                zerod_element_values = []
                for e in params.zerod_element_type:
                    if e in model:
                        zerod_element_values += [model[e][branch][i]]
                    else:
                        raise ValueError('Unknown 0D-element ' + e + '. Choose from ' + str(model.keys()))

                out += " " + params.zerod_element_type + ''.join(sp + str(val) for val in zerod_element_values)
            else:
                # todo: need to account for 0d models where the 0d elements / segments have different 0d element types (in other words, have multiple 0d element types in a single 0d model)
                msg = "Non-uniform 0d element types (meaning each 0d element in the 0d model does not have the same 0d element type) not implemented yet."
                mesh.logger.error(msg)
                raise RuntimeError(msg)

            if 'f_sten' in model:
                out += ' f_sten ' + repr(model['f_sten'][branch])

            ofile.writeln(out)

    ofile.writeln("")
    ofile.writeln("")
    ofile.writeln("DATATABLE INFLOW LIST")

    if not inflow_data:
        ofile.writeln("Copy and paste inflow data here.")
    else:
        for value in inflow_data:
            ofile.writeln(" %f %f" % (value.time, value.flow))

    ofile.writeln("ENDDATATABLE")
    ofile.writeln("")
    ofile.writeln("")

    if uniform_bc:
        ofile.writeln("DATATABLE " + outflow_bc_uc + "_1 LIST")
        ofile.writeln(sp)
        ofile.writeln("ENDDATATABLE")
        ofile.writeln("")
    else:
        for i, name in enumerate(mesh.outlet_face_names_index.keys()):
            bc_val = mesh.bc_map[name]
            bc_type = mesh.bc_type[name]
            ofile.writeln("DATATABLE " + bc_type.upper() + "_" + str(i) + " LIST")

            if bc_type == OutflowBoundaryConditionType.RCR or bc_type == OutflowBoundaryConditionType.RESISTANCE:
                for j in bc_val:
                    ofile.writeln("0.0 " + str(j))

            elif bc_type == OutflowBoundaryConditionType.CORONARY:
                # write parameters
                for v in ['Ra1', 'Ra2', 'Ca', 'Cc', 'Rv1', 'P_v']:
                    ofile.writeln("-1.0 " + str(bc_val['var'][v]))

                # write time / pressure pairs
                for t, p in zip(bc_val['time'], bc_val['pressure']):
                    ofile.writeln(str(t) + sp + str(p))

            ofile.writeln("ENDDATATABLE")
            ofile.writeln("")

    ofile.writeln("")
    ofile.writeln("")


def write_inlet_bc(mesh, ofile, params):
    """ Write a solver input file inlet boundary condition section.
    """
    # todo: update this function to work for any BC (flow, pressure, etc) for the inlet segment
    header = Headers().inlet_bc
    write_solver_section_header(mesh, ofile, header)

    inlet_face_seg_num = params.inlet_face_seg_num

    ofile.writeln("INLET_BOUNDARY_CONDITION " + str(inlet_face_seg_num) + " FLOW INFLOW")
    ofile.writeln("")


def write_solver_options(mesh, ofile, params):
    """ Write a solver input file solver options section.
    """
    header = Headers().solveroptions_0d
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space

    # time step size
    dt = params.time_step

    # number of steps
    n_step = params.num_time_steps

    # cardiac cycle length
    t_cycle = mesh.inflow_data[-1][0]

    # derive 0d parameters
    number_of_time_pts_per_cardiac_cycle = int(t_cycle/dt)
    number_of_cardiac_cycles = int(n_step / t_cycle * dt) + 1

    ofile.writeln("SOLVEROPTIONS_0D " + str(number_of_time_pts_per_cardiac_cycle) + sp + str(number_of_cardiac_cycles))
    ofile.writeln("")
