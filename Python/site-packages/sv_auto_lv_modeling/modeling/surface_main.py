# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import sys
sys.path.append(os.path.join(os.path.dirname(
__file__), "src"))

import glob
import numpy as np
import io_utils
from image_processing import LVImage
from models import LeftVentricle, LeftHeart
from marching_cube import marching_cube, vtk_marching_cube
import utils
import vtk
import time

def build_lv_model_from_image(fns, poly_fns, ug_fn=None, remove_ids=[1,4,5,7],la_id=2,aa_id=6, edge_size = 1., timming=False, use_SV=True):
    """
    Modified test6 to cut on the PolyData directly to create better defined inlet/outlet geometry
    The left atrium is cut normal to the direction defined by the normal of the mitral plane
    The amount of left atrium kept can be adjusted by a scalar factor, 
    which scales the distance between mv plane centroid and la centroid

    Args:
        fns: list containing the paths to images
        fns_out: output file names (poly_fn, ug_fn)
    Returns:
        model: constructed surface mesh (VTK PolyData)
        cap_pts_ids: node ids of the points on the caps
    """
    FACTOR_LA = 18
    FACTOR_AA = 38
    MESH_RESOLUTION = (1.,1.,1.)
        
        
    time_list = []
    if timming:
        start = time.time()
    for fn, poly_fn in zip(fns,poly_fns): 
        image = LVImage(fn)
        image.process(remove_ids)

        la_cutter = image.build_cutter(la_id, aa_id, 3, FACTOR_LA, op='valve')
        aa_cutter = image.build_cutter(aa_id, la_id, 3, FACTOR_AA, op='tissue')
        image.resample(MESH_RESOLUTION, 'linear')
        image.convert_to_binary()

        if timming:
            im_time = time.time() - start
            time_now = time.time()
        
        model = LeftVentricle(image.generate_surface(0, smooth_iter=20, band=0.02))
        #process models
        model.process_wall(*la_cutter, *aa_cutter)
        model.process_cap(5.) 
        if timming:
            surf_time = time.time() - time_now
            time_now = time.time()
        try:
            os.makedirs(os.path.join(os.path.dirname(poly_fn), "geometry"))
        except Exception as e: print(e)
        fn = os.path.join(os.path.dirname(poly_fn), "geometry", os.path.basename(poly_fn))
        if use_SV:
            model.remesh(edge_size, fn, poly_fn, ug_fn)
        model.write_surface_mesh(poly_fn)
        if timming:
            mesh_time = time.time() - time_now
            time_list.append([im_time, surf_time, mesh_time])
    return time_list

def build_left_heart_model_from_image(fns, poly_fns, ug_fn=None, remove_ids=[1,4,5,7], la_id=2, aa_id=6, edge_size = 1., timming=False, use_SV=True):
    
    MESH_RESOLUTION = (0.5,0.5,0.5)
    FACTOR_AA = 38
        
    time_list = []
    if timming:
        start = time.time()
    for fn, poly_fn in zip(fns,poly_fns): 

        image = LVImage(fn)
        image.process(remove_ids)

        aa_cutter = image.build_cutter(aa_id, la_id, 3, FACTOR_AA, op='tissue')
        image.resample(MESH_RESOLUTION, 'linear')
        image.convert_to_binary()
        image.erase_boundary()

        if timming:
            im_time = time.time() - start
            time_now = time.time()
        
        model = LeftHeart(image.generate_surface(0, smooth_iter=20, band=0.02))
        model.process_wall(*aa_cutter)
        model.process_cap(5.) 
        if timming:
            surf_time = time.time() - time_now
            time_now = time.time()
        fn = os.path.join(os.path.dirname(__file__), "debug", os.path.basename(poly_fn))
        if use_SV:
            model.remesh(edge_size, fn, poly_fn, ug_fn)
        model.write_surface_mesh(poly_fn)
        if timming:
            mesh_time = time.time() - time_now
            time_list.append([im_time, surf_time, mesh_time])
    return time_list

if __name__=="__main__":
    start = time.time()
    #from pip._internal import main as pipmain
    #pipmain(['install', 'scipy'])
   
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--disable_SV',default=True, action='store_false', help='Whether to disable SV for remeshing')
    parser.add_argument('--input_dir', help='Path to the segmentation directory')
    parser.add_argument('--output_dir', help='Path to the output directory')
    parser.add_argument('--edge_size', type=float, help='Maximum edge size of the surface mesh')
    args = parser.parse_args()
    
    try:
        os.makedirs(os.path.join(args.output_dir))
    except Exception as e: print(e)
    
    seg_fns = glob.glob(os.path.join(args.input_dir, "*.nii.gz")) + \
            glob.glob(os.path.join(args.input_dir, "*.nii")) + \
            glob.glob(os.path.join(args.input_dir, "*.vti"))
    for seg_fn in seg_fns:
        fn_poly = os.path.join(args.output_dir, os.path.basename(seg_fn)+'.vtp')
        time_list = build_lv_model_from_image([seg_fn], [fn_poly], edge_size=args.edge_size, timming=False, use_SV=args.disable_SV)
