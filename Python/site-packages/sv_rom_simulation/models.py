# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
bla
"""
import numpy as np
from collections import defaultdict
from scipy.signal import argrelextrema
import pdb

# todo: move modeling stuff from Mesh class in ROM base class. ZeroD, OneD inherit from base class


class ZeroD(object):
    """
    Contains all 0D building blocks
    """

    def __init__(self, mesh, params):
        self.mesh = mesh
        self.params = params
        self.model = None

    def generate(self):
        """
        bla
        """
        self.model = {'R_poiseuille': defaultdict(list),
                      'C': defaultdict(list),
                      'L': defaultdict(list),
                      'stenosis_coefficient': defaultdict(list)}

        # loop branches
        for (br, ids) in self.mesh.cell_data['id'].items():

            # loop segments
            for seg, _ in enumerate(ids):
                self.model['stenosis_coefficient'][br] += [self.get_factor_stenosis(br, seg)]

                # segment length
                length = self.mesh.cell_data['length'][br][seg]

                # segment average radius
                avg_radius = self.get_segment_avg_radius(br, seg)

                # calculate 0D elements
                self.model['R_poiseuille'][br] += [self.get_resistance_viscous(length, avg_radius)]
                self.model['C'][br] += [self.get_capacitance(length, avg_radius)]
                self.model['L'][br] += [self.get_inductance(length, avg_radius)]

        return self.model

    def get_factor_stenosis(self, br, seg):
        """
        See (7) in Mirramezani and Shadden, 2020
        """

        # get branch ids
        branch = self.mesh.get_point_data(self.mesh.PointDataFields.BRANCH)

        # get all branch points
        point_ids = np.where(branch == br)

        if seg == 0:
            l0 = 0
        else:
            l0 = np.cumsum(self.mesh.cell_data['length'][br])[seg - 1]
        l1 = np.cumsum(self.mesh.cell_data['length'][br])[seg]

        path = self.mesh.get_point_data(self.mesh.PointDataFields.PATH)[point_ids]
        seg_ids = np.logical_and(path >= l0, path <= l1)

        # get point arrays from centerline
        area = self.mesh.get_point_data(self.mesh.PointDataFields.AREA)[point_ids][seg_ids]

        # find extrema
        i_min = argrelextrema(area, np.less)
        i_max = argrelextrema(area, np.greater)

        # truncate minima and maxima
        a_0 = area[i_min]
        a_s = area[i_max]
        if len(a_0) > len(a_s):
            a_0 = a_0[:-1]
        elif len(a_0) < len(a_s):
            a_s = a_s[1:]

        # empirical loss constant
        k_t = 1.52

        return np.sum(k_t * self.params.density / 2 / a_0 ** 2 * (a_0 / a_s - 1) ** 2)

    def get_resistance_viscous(self, length, avg_radius):
        """
        Calculate viscous resistance using Poiseuille flow
        """
        return 8.0 * self.params.viscosity * length / (np.pi * (avg_radius ** 4))

    def get_capacitance(self, length, avg_radius):
        """
        Compute capacitance using Poiseuille flow
        """
        return 3.0 * length * np.pi * (avg_radius ** 2) / (2 * self.get_vessel_stiffness(avg_radius))

    def get_inductance(self, length, avg_radius):
        """
        Compute inductance using Poiseuille flow
        """
        return length * self.params.density / (np.pi * (avg_radius ** 2))

    def get_segment_avg_radius(self, br, seg):
        """
        Compute average segment radius from inlet and outlet area
        """
        a0 = self.mesh.point_data['area'][br][seg]
        a1 = self.mesh.point_data['area'][br][seg + 1]
        return (np.sqrt(a0 / np.pi) + np.sqrt(a1 / np.pi)) / 2.0

    def get_vessel_stiffness(self, r):
        """
        Get vessel stiffness depending on constitutive law
        """
        if self.params.material_model == "OLUFSEN":
            k1 = self.params.olufsen_material_k1
            k2 = self.params.olufsen_material_k2
            k3 = self.params.olufsen_material_k3
            return k1 * np.exp(k2 * r) + k3
        elif self.params.material_model == "LINEAR":
            return self.params.linear_material_ehr
        else:
            raise ValueError("Material type " + self.params.material_type + " unknown (choose OLUFSEN or LINEAR).")


class OneD(object):
    """
    Add 1D building blocks?
    """

    def __init__(self, mesh, params):
        self.mesh = mesh
        self.params = params
        pass

    def generate(self):
        """
        bla
        """
        pdb.set_trace()
