# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import json
import pdb
import numpy as np
from collections import defaultdict

from .parameters import OutflowBoundaryConditionType


def write_0d_solver_file(mesh, params, model):
    """
    Generate 0d solver input file (.json)
    """
    # get mesh statistics

    # create input dictionary
    inp = defaultdict(dict)
    inp['model_name'] = params.model_name

    # time
    dt = params.time_step
    n_step = params.num_time_steps
    t_cycle = mesh.inflow_data[-1][0]
    inp['number_of_time_pts_per_cardiac_cycle'] = int(t_cycle / dt)
    inp['number_of_cardiac_cycles'] = int(n_step / t_cycle * dt) + 1

    # fluid
    inp['density'] = params.density
    inp['viscosity'] = params.viscosity

    # nodes
    for ids, nodes in zip(mesh.point_data['id'].values(), mesh.point_data['coord'].values()):
        for i, node in zip(ids, nodes):
            inp['node_coordinates'][str(i)] = node.tolist()

    # segments
    inp['boundary_condition_types'] = {'inlet': {'0': 'FLOW'}, 'outlet': {}}
    inp['boundary_condition_datatable_names'] = {'inlet': {'0': 'INFLOW'}, 'outlet': {}}
    for (branch, ids), lengths in zip(mesh.cell_data['id'].items(), mesh.cell_data['length'].values()):
        for i, (j, length) in enumerate(zip(ids, lengths)):
            if j in mesh.terminal:
                bc_id = mesh.terminal.index(j)
                bc_name = list(mesh.outlet_face_names_index.keys())[bc_id]
                bc_type = mesh.bc_type[bc_name].upper()
                bc_str = bc_type + "_" + str(bc_id)
                inp['boundary_condition_types']['outlet'][str(j)] = bc_type
                inp['boundary_condition_datatable_names']['outlet'][str(j)] = bc_str
            inp['segment_names'][str(j)] = 'branch' + str(branch) + '_seg' + str(i)
            inp['lengths'][str(j)] = length
            inp['segment_0d_values'][str(j)] = {}
            for zerod in model.keys():
                inp['segment_0d_values'][str(j)][zerod] = model[zerod][branch][i]

    # junctions
    for i, junction in enumerate(mesh.seg_connectivity):
        jn = 'J' + str(i)
        inp['junction_types'][jn] = 'NORMAL_JUNCTION'
        inp['joint_name_to_segments_map'][jn] = {'inlet': [int(junction[0])], 'outlet': []}
        for j in junction[1:]:
            inp['joint_name_to_segments_map'][jn]['outlet'] += [int(j)]

    # inflow
    inflow_q = []
    inflow_t = []
    for value in mesh.inflow_data:
        inflow_t += [value.time]
        inflow_q += [value.flow]
    inp['datatable_values']['INFLOW'] = {'t': inflow_t, 'Q': inflow_q}

    # outflow
    for bc_name, i in mesh.outlet_face_names_index.items():
        bc_type = mesh.bc_type[bc_name]
        bc_str = mesh.bc_type[bc_name].upper() + '_' + str(i)
        bc_val = mesh.bc_map[bc_name]

        inp['datatable_values'][bc_str] = {}
        if bc_type == OutflowBoundaryConditionType.RCR:
            seq = ['Rp', 'C', 'Rd', 'Pd']
            for name, val in zip(seq, bc_val):
                inp['datatable_values'][bc_str][name] = float(val)
        elif bc_type == OutflowBoundaryConditionType.RESISTANCE:
            seq = ['R', 'Pd']
            for name, val in zip(seq, bc_val):
                inp['datatable_values'][bc_str][name] = float(val)
        elif bc_type == OutflowBoundaryConditionType.CORONARY:
            for name, val in bc_val['var'].items():
                inp['datatable_values'][bc_str][name] = val
            inp['datatable_values'][bc_str]['t'] = bc_val['time']
            inp['datatable_values'][bc_str]['Pim'] = bc_val['pressure']

    # write to file
    file_name = os.path.join(params.output_directory, params.solver_output_file)
    with open(file_name, 'w') as file:
        json.dump(inp, file, indent=4, sort_keys=True)
