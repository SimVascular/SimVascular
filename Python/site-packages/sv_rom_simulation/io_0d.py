# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
This module handles file i/o for the SimVascular 0D solver
"""
from os import path
import logging
import re
import json

from .manage import get_logger_name
from .parameters import OutflowBoundaryConditionType, MaterialModel

import numpy as np
from collections import OrderedDict, defaultdict

import vtk.util.numpy_support as nps
from vtk import vtkIdList
from vtk import vtkPoints, vtkLine, vtkCellArray, vtkPolyData, vtkXMLPolyDataWriter
from .utils import SurfaceFileFormats, read_polydata, write_polydata
from .io_1d import write_solver_section_header, write_solver_joints, write_solver_nodes
from .io_headers import Headers
from collections import namedtuple
import pdb

# Define flow data tuple.
FlowData = namedtuple('FlowData', 'time flow')


def write_0d_solver_file_json(mesh, params, model):
    # get mesh statistics
    mesh.num_elements = mesh.num_seg

    inp = defaultdict(dict)

    write_solver_options_json(inp, mesh, params)

    inp['model_name'] = params.model_name
    inp['inlet_segments_of_model'] = [0]
    inp['outlet_segments_of_model'] = np.array(mesh.terminal).tolist()

    # UNUSED
    inp['Ehor_func'] = {}
    inp['material_names'] = {}
    inp['material_types'] = {}

    # nodes
    for ids, nodes in zip(mesh.point_data['id'].values(), mesh.point_data['coord'].values()):
        for i, node in zip(ids, nodes):
            inp['node_coordinates'][str(i)] = node.tolist()

    # segments
    inp['boundary_condition_types'] = {'inlet': {'0': 'FLOW'}, 'outlet': {}}
    inp['boundary_condition_datatable_names'] = {'inlet': {'0': 'INFLOW'}, 'outlet': {}}
    for (branch, ids), lengths in zip(mesh.cell_data['id'].items(), mesh.cell_data['length'].values()):
        for i, (j, length) in enumerate(zip(ids, lengths)):
            if j in mesh.terminal:
                bc_id = mesh.terminal.index(j)
                bc_name = list(mesh.outlet_face_names_index.keys())[bc_id]
                bc_type = mesh.bc_type[bc_name].upper()
                bc_str = bc_type + "_" + str(bc_id)
            else:
                bc_str = 'NONE'
                bc_type = 'NOBOUND'
            inp['boundary_condition_types']['outlet'][str(j)] = bc_type
            inp['boundary_condition_datatable_names']['outlet'][str(j)] = bc_str
            inp['segment_names'][str(j)] = 'branch' + str(branch) + '_seg' + str(i)
            inp['segment_0d_values'][str(j)] = [model['R'][branch][i], model['f_sten'][branch][i]]
            inp['lengths'][str(j)] = length
            inp['Ehor_values'][str(j)] = -1.0  # UNUSED

            p0 = mesh.point_data['id'][branch][i]
            p1 = mesh.point_data['id'][branch][i + 1]
            inp['nodes_of_segments'][str(j)] = [int(p0), int(p1)]

    # junctions
    for i, junction in enumerate(mesh.seg_connectivity):
        jn = 'J' + str(i)
        inp['junction_types'][jn] = 'NORMAL_JUNCTION'
        inp['joint_name_to_segments_map'][jn] = {'inlet': [int(junction[0])], 'outlet': []}
        for j in junction[1:]:
            inp['joint_name_to_segments_map'][jn]['outlet'] += [int(j)]

        # UNUSED
        inp['joint_node_numbers'][jn] = int(mesh.seg_rear[i])
        inp['joint_inlet_names'][jn] = 'IN' + str(i)
        inp['joint_inlet_segments']['IN' + str(i)] = [int(junction[0])]
        inp['joint_outlet_names'][jn] = 'OUT' + str(i)
        inp['joint_outlet_segments']['OUT' + str(i)] = []
        for j in junction[1:]:
            inp['joint_outlet_segments']['OUT' + str(i)] += [int(j)]

    # inflow
    inflow_list = []
    for value in mesh.inflow_data:
        inflow_list += [value.time, value.flow]
    inp['datatable_values']['INFLOW'] = inflow_list

    # outflow
    for bc_name, i in mesh.outlet_face_names_index.items():
        bc_type = mesh.bc_type[bc_name]
        bc_str = mesh.bc_type[bc_name].upper() + '_' + str(i)
        bc_val = mesh.bc_map[bc_name]

        inp['datatable_values'][bc_str] = []
        if bc_type == OutflowBoundaryConditionType.RCR or bc_type == OutflowBoundaryConditionType.RESISTANCE:
            for val in bc_val:
                inp['datatable_values'][bc_str] += [0.0, float(val)]
        elif bc_type == OutflowBoundaryConditionType.CORONARY:
            for v in ['Ra1', 'Ra2', 'Ca', 'Cc', 'Rv1', 'P_v']:
                inp['datatable_values'][bc_str] += [-1.0, bc_val['var'][v]]
            for t, p in zip(bc_val['time'], bc_val['pressure']):
                inp['datatable_values'][bc_str] += [t, p]

    # UNUSED
    for k in inp['datatable_values'].keys():
        inp['datatable_types'][str(k)] = 'LIST'
    for i in range(mesh.num_seg):
        inp['radii'][str(i)] = -1.0
        inp['rho'][str(i)] = 1.06
        inp['mu'][str(i)] = 0.04
        inp['segment_tangent_vectors'][str(i)] = [-1.0, -1.0, -1.0]
        inp['segment_0d_types'][str(i)] = 'STENOSIS'
    inp['segment_numbers_list'] = np.arange(mesh.num_seg).tolist()

    # write to file
    file_name = path.join(params.output_directory, params.solver_output_file)
    with open(file_name, 'w') as file:
        json.dump(inp, file, indent=4, sort_keys=True)


def write_0d_solver_file(mesh, params, model):
    """ Write a 0d solver input file.
    """
    # print("Write solver file.")
    mesh.logger.info("Write 0d solver file.")
    output_dir = params.output_directory
    file_name = path.join(output_dir, params.solver_output_file)
    model_name = params.model_name
    sp = mesh.space
    # print("Solver file %s" % file_name)

    # Open file
    ofile = mesh.Open(file_name, "w")

    # write header
    header = Headers().model(model_name)
    write_solver_section_header(mesh, ofile, header)

    # Write node section.
    write_solver_nodes(mesh, ofile, params)

    # Write joint section.
    write_solver_joints(mesh, ofile, params)

    # Write junctions section.
    write_solver_junctions(mesh, ofile)

    # Write element section.
    write_solver_elements(mesh, model, ofile, params)

    # Write inlet boundary condition section.
    write_inlet_bc(mesh, ofile, params)

    # Write solver options section.
    write_solver_options(mesh, ofile, params)

    ofile.close()


def write_solver_junctions(mesh, ofile):
    """ Write a solver input file junctions section.
    """
    # todo: update this function to work for any junction model, ie NORMAL_JUNCTION or LOSSY_JUNCTION
    header = Headers().junction

    # Junction header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space

    for i in range(0, len(mesh.seg_connectivity)):
        junction = "JUNCTION_MODEL J" + str(i) + sp + "NORMAL_JUNCTION"
        ofile.writeln(junction)
    ofile.write("\n")


def write_solver_elements(mesh, model, ofile, params):
    """ Write a solver input file elements section.
    """
    # todo: clean up this functions; there are some leftover remnants from that 1d version of this function ( write_solver_segments() ) that I dont need for this 0d version
    header = Headers().element
    write_solver_section_header(mesh, ofile, header)
    mesh.logger.info("Write solver element section ...")

    sp = mesh.space

    uniform_bc = params.uniform_bc
    uniform_material = params.uniform_material
    dx = params.element_size
    min_num_elems = params.min_num_elems
    inflow_data = mesh.inflow_data

    mesh.logger.info("Uniform BC: %s" % uniform_bc)
    for t in set(mesh.bc_type.values()):
        mesh.logger.info("Outflow BC: %s" % t)
    mesh.num_elements = 0

    assert uniform_material, 'non-uniform material not implemented'

    # loop branches
    for (branch, ids), lengths in zip(mesh.cell_data['id'].items(), mesh.cell_data['length'].values()):
        # loop nodes
        for i, (j, length) in enumerate(zip(ids, lengths)):
            numfe = int(round(length / dx))

            if numfe < min_num_elems:
                numfe = min_num_elems

            mesh.num_elements += numfe

            p0 = mesh.point_data['id'][branch][i]
            p1 = mesh.point_data['id'][branch][i + 1]

            # todo: update this function to work for an element with ANY properties (ie density, viscosity, Ehor, etc)
            ofile.write("ELEMENT" + sp + "branch" + str(branch) + "_seg" + str(i) + sp + str(j) + sp +
                        str(-1) + sp +
                        str(length) + sp + str(params.density) + sp + str(params.viscosity) + sp + str(-1) + sp + str(p0) + sp +
                        str(p1) + sp + str(-1) + sp + str(-1) + sp + str(-1))

            if j in mesh.terminal:
                if uniform_bc:
                    outflow_bc = OutflowBoundaryConditionType.RCR.upper()
                    ofile.write(" " + outflow_bc + " " + outflow_bc + "_1")
                    msg = "While writing solver elements encountered: group_terminal[seg_list[i]] == 1"
                    mesh.logger.error(msg)
                    raise RuntimeError(msg)
                else:
                    bc_id = mesh.terminal.index(j)
                    bc_name = list(mesh.outlet_face_names_index.keys())[bc_id]
                    bc_type = mesh.bc_type[bc_name].upper()
                    ofile.write(" " + bc_type + " " + bc_type + "_" + str(bc_id))
            else:
                ofile.write(" NOBOUND NONE")

            out = ''
            if params.uniform_0d_element_type:
                zerod_element_values = []
                for e in params.zerod_element_type:
                    if e in model:
                        zerod_element_values += [model[e][branch][i]]
                    else:
                        raise ValueError('Unknown 0D-element ' + e + '. Choose from ' + str(model.keys()))

                if 'f_sten' in model:
                    name = 'STENOSIS'
                else:
                    name = params.zerod_element_type
                out += " " + name + ''.join(sp + str(val) for val in zerod_element_values)
            else:
                # todo: need to account for 0d models where the 0d elements / segments have different 0d element types (in other words, have multiple 0d element types in a single 0d model)
                msg = "Non-uniform 0d element types (meaning each 0d element in the 0d model does not have the same 0d element type) not implemented yet."
                mesh.logger.error(msg)
                raise RuntimeError(msg)

            if 'f_sten' in model:
                out += ' ' + repr(model['f_sten'][branch][i])

            ofile.writeln(out)

    ofile.writeln("")
    ofile.writeln("")
    ofile.writeln("DATATABLE INFLOW LIST")

    if not inflow_data:
        ofile.writeln("Copy and paste inflow data here.")
    else:
        for value in inflow_data:
            ofile.writeln(" %f %f" % (value.time, value.flow))

    ofile.writeln("ENDDATATABLE")
    ofile.writeln("")
    ofile.writeln("")

    if uniform_bc:
        ofile.writeln("DATATABLE " + outflow_bc_uc + "_1 LIST")
        ofile.writeln(sp)
        ofile.writeln("ENDDATATABLE")
        ofile.writeln("")
    else:
        for i, name in enumerate(mesh.outlet_face_names_index.keys()):
            bc_val = mesh.bc_map[name]
            bc_type = mesh.bc_type[name]
            ofile.writeln("DATATABLE " + bc_type.upper() + "_" + str(i) + " LIST")

            if bc_type == OutflowBoundaryConditionType.RCR or bc_type == OutflowBoundaryConditionType.RESISTANCE:
                for j in bc_val:
                    ofile.writeln("0.0 " + str(j))

            elif bc_type == OutflowBoundaryConditionType.CORONARY:
                # write parameters
                for v in ['Ra1', 'Ra2', 'Ca', 'Cc', 'Rv1', 'P_v']:
                    ofile.writeln("-1.0 " + str(bc_val['var'][v]))

                # write time / pressure pairs
                for t, p in zip(bc_val['time'], bc_val['pressure']):
                    ofile.writeln(str(t) + sp + str(p))

            ofile.writeln("ENDDATATABLE")
            ofile.writeln("")

    ofile.writeln("")
    ofile.writeln("")


def write_inlet_bc(mesh, ofile, params):
    """ Write a solver input file inlet boundary condition section.
    """
    # todo: update this function to work for any BC (flow, pressure, etc) for the inlet segment
    header = Headers().inlet_bc
    write_solver_section_header(mesh, ofile, header)

    inlet_face_seg_num = params.inlet_face_seg_num

    ofile.writeln("INLET_BOUNDARY_CONDITION " + str(inlet_face_seg_num) + " FLOW INFLOW")
    ofile.writeln("")


def write_solver_options(mesh, ofile, params):
    """ Write a solver input file solver options section.
    """
    header = Headers().solveroptions_0d
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space

    # time step size
    dt = params.time_step

    # number of steps
    n_step = params.num_time_steps

    # cardiac cycle length
    t_cycle = mesh.inflow_data[-1][0]

    # derive 0d parameters
    number_of_time_pts_per_cardiac_cycle = int(t_cycle/dt)
    number_of_cardiac_cycles = int(n_step / t_cycle * dt) + 1

    ofile.writeln("SOLVEROPTIONS_0D " + str(number_of_time_pts_per_cardiac_cycle) + sp + str(number_of_cardiac_cycles))
    ofile.writeln("")


def write_solver_options_json(inp, mesh, params):
    """
    Write a solver input file solver options section.
    """
    # time step size
    dt = params.time_step

    # number of steps
    n_step = params.num_time_steps

    # cardiac cycle length
    t_cycle = mesh.inflow_data[-1][0]

    # derive 0d parameters
    inp['number_of_time_pts_per_cardiac_cycle'] = int(t_cycle / dt)
    inp['number_of_cardiac_cycles'] = int(n_step / t_cycle * dt) + 1
