# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
This module handles file i/o for the SimVascular 0D solver
"""
from os import path
import logging
import re
import json

from .manage import get_logger_name
from .parameters import OutflowBoundaryConditionType, MaterialModel

import numpy as np
from collections import OrderedDict, defaultdict

import vtk.util.numpy_support as nps
from vtk import vtkIdList
from vtk import vtkPoints, vtkLine, vtkCellArray, vtkPolyData, vtkXMLPolyDataWriter
from .utils import SurfaceFileFormats, read_polydata, write_polydata
from .io_1d import write_solver_section_header, write_solver_joints, write_solver_nodes
from .io_headers import Headers
from collections import namedtuple
import pdb

# Define flow data tuple.
FlowData = namedtuple('FlowData', 'time flow')


def write_0d_solver_file(mesh, params, model):
    # get mesh statistics
    mesh.num_elements = mesh.num_seg

    inp = defaultdict(dict)
    inp['model_name'] = params.model_name

    write_solver_options_json(inp, mesh, params)

    # time
    dt = params.time_step
    n_step = params.num_time_steps
    t_cycle = mesh.inflow_data[-1][0]
    inp['number_of_time_pts_per_cardiac_cycle'] = int(t_cycle / dt)
    inp['number_of_cardiac_cycles'] = int(n_step / t_cycle * dt) + 1

    # nodes
    for ids, nodes in zip(mesh.point_data['id'].values(), mesh.point_data['coord'].values()):
        for i, node in zip(ids, nodes):
            inp['node_coordinates'][str(i)] = node.tolist()

    # segments
    inp['inlet_segments_of_model'] = [0]
    inp['outlet_segments_of_model'] = np.array(mesh.terminal).tolist()
    inp['boundary_condition_types'] = {'inlet': {'0': 'FLOW'}, 'outlet': {}}
    inp['boundary_condition_datatable_names'] = {'inlet': {'0': 'INFLOW'}, 'outlet': {}}
    for (branch, ids), lengths in zip(mesh.cell_data['id'].items(), mesh.cell_data['length'].values()):
        for i, (j, length) in enumerate(zip(ids, lengths)):
            if j in mesh.terminal:
                bc_id = mesh.terminal.index(j)
                bc_name = list(mesh.outlet_face_names_index.keys())[bc_id]
                bc_type = mesh.bc_type[bc_name].upper()
                bc_str = bc_type + "_" + str(bc_id)
            else:
                bc_str = 'NONE'
                bc_type = 'NOBOUND'
            inp['boundary_condition_types']['outlet'][str(j)] = bc_type
            inp['boundary_condition_datatable_names']['outlet'][str(j)] = bc_str
            inp['segment_names'][str(j)] = 'branch' + str(branch) + '_seg' + str(i)
            inp['segment_0d_values'][str(j)] = [model['R'][branch][i], model['f_sten'][branch][i]]
            inp['lengths'][str(j)] = length
            inp['Ehor_values'][str(j)] = -1.0  # UNUSED

            p0 = mesh.point_data['id'][branch][i]
            p1 = mesh.point_data['id'][branch][i + 1]
            inp['nodes_of_segments'][str(j)] = [int(p0), int(p1)]

    # junctions
    for i, junction in enumerate(mesh.seg_connectivity):
        jn = 'J' + str(i)
        inp['junction_types'][jn] = 'NORMAL_JUNCTION'
        inp['joint_name_to_segments_map'][jn] = {'inlet': [int(junction[0])], 'outlet': []}
        for j in junction[1:]:
            inp['joint_name_to_segments_map'][jn]['outlet'] += [int(j)]

        # UNUSED
        inp['joint_node_numbers'][jn] = int(mesh.seg_rear[i])
        inp['joint_inlet_names'][jn] = 'IN' + str(i)
        inp['joint_inlet_segments']['IN' + str(i)] = [int(junction[0])]
        inp['joint_outlet_names'][jn] = 'OUT' + str(i)
        inp['joint_outlet_segments']['OUT' + str(i)] = []
        for j in junction[1:]:
            inp['joint_outlet_segments']['OUT' + str(i)] += [int(j)]

    # inflow
    inflow_list = []
    for value in mesh.inflow_data:
        inflow_list += [value.time, value.flow]
    inp['datatable_values']['INFLOW'] = inflow_list

    # outflow
    for bc_name, i in mesh.outlet_face_names_index.items():
        bc_type = mesh.bc_type[bc_name]
        bc_str = mesh.bc_type[bc_name].upper() + '_' + str(i)
        bc_val = mesh.bc_map[bc_name]

        inp['datatable_values'][bc_str] = []
        if bc_type == OutflowBoundaryConditionType.RCR or bc_type == OutflowBoundaryConditionType.RESISTANCE:
            for val in bc_val:
                inp['datatable_values'][bc_str] += [0.0, float(val)]
        elif bc_type == OutflowBoundaryConditionType.CORONARY:
            for v in ['Ra1', 'Ra2', 'Ca', 'Cc', 'Rv1', 'P_v']:
                inp['datatable_values'][bc_str] += [-1.0, bc_val['var'][v]]
            for t, p in zip(bc_val['time'], bc_val['pressure']):
                inp['datatable_values'][bc_str] += [t, p]

    # UNUSED
    inp['Ehor_func'] = {}
    inp['material_names'] = {}
    inp['material_types'] = {}
    for k in inp['datatable_values'].keys():
        inp['datatable_types'][str(k)] = 'LIST'
    for i in range(mesh.num_seg):
        inp['radii'][str(i)] = -1.0
        inp['rho'][str(i)] = 1.06
        inp['mu'][str(i)] = 0.04
        inp['segment_tangent_vectors'][str(i)] = [-1.0, -1.0, -1.0]
        inp['segment_0d_types'][str(i)] = 'STENOSIS'
    inp['segment_numbers_list'] = np.arange(mesh.num_seg).tolist()

    # write to file
    file_name = path.join(params.output_directory, params.solver_output_file)
    with open(file_name, 'w') as file:
        json.dump(inp, file, indent=4, sort_keys=True)
